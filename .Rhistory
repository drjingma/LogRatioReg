library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# testing with centered and/or scaled y
y = scale(y, center = F, scale = F)
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
################################################################################
# fit lm with intercept : lm(y ~ log.X.prop)
################################################################################
final.data = data.frame(log.X.prop[, final.selected], y)
final.lm = lm(y ~ ., final.data)
coefficients(final.lm)
################################################################################
# fit lm withOUT intercept : lm(y ~ -1 + log.X.prop)
################################################################################
final.lm.noint = lm(y ~ -1 + ., final.data)
coefficients(final.lm.noint)
beta.lm.noint = coefficients(final.lm.noint)
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
sum(beta.bar.s)
beta.bar.s
beta.bar.s2 = beta.bar.s * x.sd
sum(beta.bar.s2) # not satisfied anymore
# constrained - with intercept
y.mean = mean(y)
y.c = y - y.mean
x.mean = colMeans(Xmat)
Xmat.c = scale(Xmat, center=x.mean, scale=F)
beta.hat.c = solve(crossprod(Xmat.c), crossprod(Xmat.c, y.c))
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
sum(beta.bar.c)
beta.bar.c
beta.bar.c0 <- y.mean - as.vector(x.mean%*%beta.bar.c)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
# constrained - with intercept and scaling
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
beta.bar.cs2 = beta.bar.s * x.sd
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
sum(beta.bar.cs0, beta.bar.cs)
beta.bar.cs
beta.bar.cs2 = beta.bar.s * x.sd
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
sum(beta.bar.cs0, beta.bar.cs)
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs0
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
sum(beta.bar.cs02, beta.bar.cs2)
beta.bar.cs02
beta.bar.cs
beta.bar.cs2 = beta.bar.s * x.sd
beta.bar.cs2
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
sum(beta.bar.cs02, beta.bar.cs2)
beta.bar.cs02
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
beta.hat
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
beta.hat.lm
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat)) # they match, as expected
beta.hat
beta.hat.lm
all.equal(beta.hat, beta.hat.lm) # they match, as expected
beta.hat.lm
beta.hat
as.numeric(beta.hat)
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
################################################################################
# fit lm with intercept : lm(y ~ log.X.prop)
################################################################################
final.data = data.frame(log.X.prop[, final.selected], y)
final.lm = lm(y ~ ., final.data)
coefficients(final.lm)
################################################################################
# fit lm withOUT intercept : lm(y ~ -1 + log.X.prop)
################################################################################
final.lm.noint = lm(y ~ -1 + ., final.data)
coefficients(final.lm.noint)
beta.lm.noint = coefficients(final.lm.noint)
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
sum(beta.bar.s)
beta.bar.s
beta.bar.s2 = beta.bar.s * x.sd
sum(beta.bar.s2) # not satisfied anymore
# constrained - with intercept
y.mean = mean(y)
y.c = y - y.mean
x.mean = colMeans(Xmat)
Xmat.c = scale(Xmat, center=x.mean, scale=F)
beta.hat.c = solve(crossprod(Xmat.c), crossprod(Xmat.c, y.c))
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
sum(beta.bar.c)
beta.bar.c
beta.bar.c0 <- y.mean - as.vector(x.mean%*%beta.bar.c)
# constrained - with intercept, including in Xmat
Xmat.c2 = cbind(1, Xmat)
beta.hat.c2 = solve(crossprod(Xmat.c2), crossprod(Xmat.c2, y))
beta.bar.c2 = beta.hat.c2 - solve(crossprod(Xmat.c2), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c2), Q)), crossprod(Q, beta.hat.c2))
beta.hat.c2
Q2 = c(0, as.matrix(rep(1, dim(Xmat)[2])))
Q2 = c(0, as.matrix(rep(1, dim(Xmat)[2])))
beta.bar.c2 = beta.hat.c2 - solve(crossprod(Xmat.c2), Q2) %*%
solve(crossprod(Q2, solve(crossprod(Xmat.c2), Q2)), crossprod(Q2, beta.hat.c2))
sum(beta.bar.c2)
beta.bar.c2
sum(beta.bar.c2[-1])
beta.bar.c2
beta.bar.c2.0 <- y.mean - as.vector(x.mean%*%beta.bar.c2)
# constrained - with intercept, including in Xmat, centered
Xmat.c3 = cbind(1, Xmat.c)
beta.hat.c3 = solve(crossprod(Xmat.c3), crossprod(Xmat.c3, y.c))
beta.bar.c3 = beta.hat.c3 - solve(crossprod(Xmat.c3), Q2) %*%
solve(crossprod(Q2, solve(crossprod(Xmat.c3), Q2)), crossprod(Q2, beta.hat.c3))
sum(beta.bar.c3[-1])
beta.bar.c3
beta.bar.c3.0 <- y.mean - as.vector(x.mean%*%beta.bar.c3)
beta.bar.c3.0 <- y.mean - as.vector(c(1, x.mean)%*%beta.bar.c3)
beta.bar.c3.0
beta.bar.c2
beta.bar.c3
beta.bar.c3.2 = beta.bar.c3 / x.sd
beta.bar.c3.2 = beta.bar.c3 / c(1, x.sd)
beta.bar.c3.2 = beta.bar.c3 / c(1, x.sd)
beta.bar.c3.2
beta.bar.c
beta.bar.c0
beta.bar.c2
beta.bar.c2.0 <- y.mean - as.vector(x.mean%*%beta.bar.c2)
beta.bar.c2
beta.bar.c
sum(beta.bar.c)
c(beta.bar.c0, beta.bar.c)
all.equal(c(beta.bar.c0, beta.bar.c), as.numeric(beta.bar.c2)) # this matches the above
sum(beta.bar)
beta.bar
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# testing with centered and/or scaled y
# y = scale(y, center = F, scale = F)
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
################################################################################
# fit lm with intercept : lm(y ~ log.X.prop)
################################################################################
final.data = data.frame(log.X.prop[, final.selected], y)
final.lm = lm(y ~ ., final.data)
coefficients(final.lm)
################################################################################
# fit lm withOUT intercept : lm(y ~ -1 + log.X.prop)
################################################################################
final.lm.noint = lm(y ~ -1 + ., final.data)
coefficients(final.lm.noint)
beta.lm.noint = coefficients(final.lm.noint)
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
################################################################################
# fit lm withOUT intercept : lm(y ~ -1 + log.X.prop)
################################################################################
final.lm.noint = lm(y ~ -1 + ., final.data)
coefficients(final.lm.noint)
beta.lm.noint = coefficients(final.lm.noint)
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
sum(beta.bar.s)
beta.bar.s
beta.bar.s2 = beta.bar.s * x.sd
sum(beta.bar.s2) # not satisfied anymore
sum(beta.bar.s)
beta.bar.s
beta.bar.s2 = beta.bar.s * x.sd
sum(beta.bar.s2) # not satisfied anymore
beta.bar.s2 = beta.bar.s / x.sd
sum(beta.bar.s2) # not satisfied anymore
beta.bar.s2
# constrained - with intercept
y.mean = mean(y)
y.c = y - y.mean
x.mean = colMeans(Xmat)
Xmat.c = scale(Xmat, center=x.mean, scale=F)
beta.hat.c = solve(crossprod(Xmat.c), crossprod(Xmat.c, y.c))
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
sum(beta.bar.c)
beta.bar.c
beta.bar.c0 <- y.mean - as.vector(x.mean%*%beta.bar.c)
# constrained - with intercept, including in Xmat
Xmat.c2 = cbind(1, Xmat)
beta.hat.c2 = solve(crossprod(Xmat.c2), crossprod(Xmat.c2, y))
Q2 = c(0, as.matrix(rep(1, dim(Xmat)[2])))
beta.bar.c2 = beta.hat.c2 - solve(crossprod(Xmat.c2), Q2) %*%
solve(crossprod(Q2, solve(crossprod(Xmat.c2), Q2)), crossprod(Q2, beta.hat.c2))
sum(beta.bar.c2[-1])
beta.bar.c2
# constrained - with intercept and scaling
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
# constrained - with intercept and scaling
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
sum(beta.bar.cs)
sum(beta.bar.c2[-1])
beta.bar.cs2 = beta.bar.s / x.sd
beta.bar.cs2
sum(beta.bar.cs2)
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs02
beta.bar.cs2
beta.bar.cs0
# constrained - with intercept and scaling
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
beta.bar.cs2 = beta.bar.s / x.sd
beta.bar.cs2
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs02
beta.bar.cs02
beta.bar.cs02
sum(beta.bar.cs02, beta.bar.cs2)
beta.bar.cs2
beta.bar.cs02
sum(beta.bar.cs2)
beta.lm = coefficients(final.lm)[-1]
beta.lm
################################################################################
# fit lm withOUT intercept : lm(y ~ -1 + log.X.prop)
################################################################################
final.lm.noint = lm(y ~ -1 + ., final.data)
coefficients(final.lm.noint)
beta.lm.noint = coefficients(final.lm.noint)
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y ~ Xmat))
beta.hat.lmint
beta.hat.c
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lmint)) # they match, as expected
beta.hat.lmint
beta.hat.c
beta.hat.c
beta.hat.lmint
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
, as.numeric(beta.hat.lmint)[-1]
beta.hat.lmint
as.numeric(beta.hat.lmint)[-1]
as.numeric(beta.hat)
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y.c ~ Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
as.numeric(beta.hat)
as.numeric(beta.hat.lmint)[-1]
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y.c ~ Xmat.c))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
as.numeric(beta.hat.lmint)[-1]
as.numeric(beta.hat)
all.equal(as.numeric(beta.hat.c), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y ~ Xmat))
all.equal(as.numeric(beta.hat.c), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
all.equal(coefficients(lm(y ~ Xmat)), coefficients(lm(y.c ~ Xmat.c)))
coefficients(lm(y.c ~ Xmat.c))
coefficients(lm(y ~ Xmat))
all.equal(coefficients(lm(y ~ Xmat))[-1], coefficients(lm(y.c ~ Xmat.c))[-1])
all.equal(coefficients(lm(y ~ Xmat)[-1]), coefficients(lm(y.c ~ Xmat.c)[-1]))
all.equal(as.numeric(beta.hat.c), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
lm(y.c ~ Xmat.c)
lm(y ~ Xmat)[-1]
coefficients(lm(y ~ Xmat)[-1]
)
# coefficients when centering match when not-centering (just not intercept, since centering gets rid of intercept)
all.equal(coefficients(lm(y ~ Xmat))[-1], coefficients(lm(y.c ~ Xmat.c))[-1])
coefficients(lm(y ~ Xmat))[-1]
# coefficients when centering match when not-centering (just not intercept, since centering gets rid of intercept)
all.equal(as.numeric(coefficients(lm(y ~ Xmat))[-1]),
as.numeric(coefficients(lm(y.c ~ Xmat.c))[-1]))
as.numeric(coefficients(lm(y ~ Xmat))
)
as.numeric(coefficients(lm(y.c ~ Xmat.c))
)
beta.hat.lmint0 =  y.mean - as.vector(x.mean%*%beta.hat.c)
beta.hat.lmint0
# compute beta.bar, constrained fit
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
sum(beta.bar.c)
beta.bar.c
# constrained - with intercept, including in Xmat
Xmat.c2 = cbind(1, Xmat)
beta.hat.c2 = solve(crossprod(Xmat.c2), crossprod(Xmat.c2, y))
Q2 = c(0, as.matrix(rep(1, dim(Xmat)[2])))
beta.bar.c2 = beta.hat.c2 - solve(crossprod(Xmat.c2), Q2) %*%
solve(crossprod(Q2, solve(crossprod(Xmat.c2), Q2)), crossprod(Q2, beta.hat.c2))
sum(beta.bar.c2[-1])
beta.bar.c2
all.equal(c(beta.bar.c0, beta.bar.c), as.numeric(beta.bar.c2)) # this matches the above
# constrained - with intercept and scaling
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
beta.bar.cs2 = beta.bar.s / x.sd
beta.bar.cs2
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs02
