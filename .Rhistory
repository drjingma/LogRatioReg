beta.hat.sub.cs = solve(crossprod(Xmat.sub.cs), crossprod(Xmat.sub.cs, y.c))
beta.bar.sub.cs = beta.hat.sub.cs - solve(crossprod(Xmat.sub.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.sub.cs), Q)), crossprod(Q, beta.hat.sub.cs))
sum(beta.bar.sub.cs)
beta.bar.sub.cs
beta.bar.sub.cs0 <- y.mean - as.vector(x.mean.sub%*%beta.bar.sub.cs)
beta.bar.sub.cs0
l2.sub.cs = sqrt(crossprod(beta.bar.sub.cs))
dist.t.sub.cs = sqrt(sum((beta.bar.sub.cs - beta.paper)^2))
l2.sub.cs
dist.t.sub.cs
yhat = beta.bar.sub.cs0 + Xmat.sub.cs %*% beta.bar.sub.cs
xyrange = range(y, yhat)
plot(main = "with int, std.", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
#
beta.bar.sub.cs2 = beta.bar.sub.cs / x.sd.sub
beta.bar.sub.cs2
sum(beta.bar.sub.cs2) # not satisfied anymore
beta.bar.sub.cs02 <- y.mean - as.vector(x.mean.sub%*%beta.bar.sub.cs2)
beta.bar.sub.cs02
sum(beta.bar.sub.cs02, beta.bar.sub.cs2)
sum(beta.bar.sub.cs2) # not satisfied anymore
l2.sub.cs2 = sqrt(crossprod(beta.bar.sub.cs2))
dist.t.sub.cs2 = sqrt(sum((beta.bar.sub.cs2 - beta.paper)^2))
l2.sub.cs2
dist.t.sub.cs2
yhat = beta.bar.sub.cs02 + Xmat.sub.cs %*% beta.bar.sub.cs2
xyrange = range(y, yhat)
plot(main = "with int, back-std.", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# combo data
combo <- read.csv("Kristyn/Data/combo_ffq_adj.txt", sep = " ")
totalcaloricfatintake = combo[, c("calor", "tfat")]
# testing with centered and/or scaled y
# y = scale(y, center = T, scale = T)
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
beta.paper = c(-0.76, -1.35, 0.61, 1.50)
################################################################################
# CONSTRAINED LINEAR MODEL
################################################################################
par(mfrow = c(2, 3))
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
Xmat = as.matrix(cbind(Xmat, totalcaloricfatintake))
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(c(rep(1, dim(Xmat)[2] - dim(totalcaloricfatintake)[2]),
rep(0, dim(totalcaloricfatintake)[2])))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
beta.bar = beta.bar[-c(5, 6)]
# sum(beta.bar)
# beta.bar
# l2 = sqrt(crossprod(beta.bar))
# dist.t = sqrt(sum((beta.bar - beta.paper)^2))
# l2
# dist.t
yhat = Xmat.s %*% beta.bar.s2
xyrange = range(y, yhat)
plot(main = "no int, back-scaled", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# combo data
combo <- read.csv("Kristyn/Data/combo_ffq_adj.txt", sep = " ")
totalcaloricfatintake = combo[, c("calor", "tfat")]
# testing with centered and/or scaled y
# y = scale(y, center = T, scale = T)
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
beta.paper = c(-0.76, -1.35, 0.61, 1.50)
################################################################################
# CONSTRAINED LINEAR MODEL
################################################################################
par(mfrow = c(2, 3))
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
Xmat = as.matrix(cbind(Xmat, totalcaloricfatintake))
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(c(rep(1, dim(Xmat)[2] - dim(totalcaloricfatintake)[2]),
rep(0, dim(totalcaloricfatintake)[2])))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
beta.bar = beta.bar[-c(5, 6)]
# sum(beta.bar)
# beta.bar
# l2 = sqrt(crossprod(beta.bar))
# dist.t = sqrt(sum((beta.bar - beta.paper)^2))
# l2
# dist.t
yhat = Xmat %*% beta.bar
xyrange = range(y, yhat)
plot(main = "no intercept", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
# beta.bar = beta.bar[-c(5, 6)]
# sum(beta.bar)
# beta.bar
# l2 = sqrt(crossprod(beta.bar))
# dist.t = sqrt(sum((beta.bar - beta.paper)^2))
# l2
# dist.t
yhat = Xmat %*% beta.bar
xyrange = range(y, yhat)
plot(main = "no intercept", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# combo data
combo <- read.csv("Kristyn/Data/combo_ffq_adj.txt", sep = " ")
totalcaloricfatintake = combo[, c("calor", "tfat")]
# testing with centered and/or scaled y
# y = scale(y, center = T, scale = T)
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
beta.paper = c(-0.76, -1.35, 0.61, 1.50)
################################################################################
# CONSTRAINED LINEAR MODEL
################################################################################
par(mfrow = c(2, 3))
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
Xmat = as.matrix(cbind(Xmat, totalcaloricfatintake))
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(c(rep(1, dim(Xmat)[2] - dim(totalcaloricfatintake)[2]),
rep(0, dim(totalcaloricfatintake)[2])))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
# beta.bar = beta.bar[-c(5, 6)]
# sum(beta.bar)
# beta.bar
# l2 = sqrt(crossprod(beta.bar))
# dist.t = sqrt(sum((beta.bar - beta.paper)^2))
# l2
# dist.t
yhat = Xmat %*% beta.bar
xyrange = range(y, yhat)
plot(main = "no intercept", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
# beta.bar.s = beta.bar.s[-c(5, 6)]
# sum(beta.bar.s)
# beta.bar.s
# l2.s = sqrt(crossprod(beta.bar.s))
# dist.t.s = sqrt(sum((beta.bar.s - beta.paper)^2))
# l2.s
# dist.t.s
yhat = Xmat.s %*% beta.bar.s
xyrange = range(y, yhat)
plot(main = "no int, scaled", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
#
beta.bar.s2 = beta.bar.s / x.sd
#
beta.bar.s2 = beta.bar.s / x.sd
# sum(beta.bar.s2) # not satisfied anymore
# beta.bar.s2
# l2.s2 = sqrt(crossprod(beta.bar.s2))
# dist.t.s2 = sqrt(sum((beta.bar.s2 - beta.paper)^2))
# l2.s2
# dist.t.s2
yhat = Xmat.s %*% beta.bar.s2
xyrange = range(y, yhat)
plot(main = "no int, back-scaled", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - with intercept
y.mean = mean(y)
y.c = y - y.mean
x.mean = colMeans(Xmat)
Xmat.c = scale(Xmat, center=x.mean, scale=F)
beta.hat.c = solve(crossprod(Xmat.c), crossprod(Xmat.c, y.c))
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y ~ Xmat))
# coefficients when centering match when not-centering (just not intercept, since centering gets rid of intercept)
all.equal(as.numeric(coefficients(lm(y ~ Xmat))[-1]),
as.numeric(coefficients(lm(y.c ~ Xmat.c))[-1]))
all.equal(as.numeric(beta.hat.c), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
beta.hat.lmint0 = y.mean - as.vector(x.mean%*%beta.hat.c) # also match
# compute beta.bar, constrained fit
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
beta.bar.c0 <- y.mean - as.vector(x.mean%*%beta.bar.c)
# beta.bar.c = beta.bar.c[-c(5, 6)]
# sum(beta.bar.c)
# beta.bar.c
# l2.c = sqrt(crossprod(beta.bar.c))
# dist.t.c = sqrt(sum((beta.bar.c - beta.paper)^2))
# l2.c
# dist.t.c
yhat = beta.bar.c0 + Xmat.c %*% beta.bar.c
xyrange = range(y, yhat)
plot(main = "with intercept", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - with intercept and scaling (standardizing, bc need to center for intercept)
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
# beta.bar.cs = beta.bar.cs[-c(5, 6)]
# sum(beta.bar.cs)
# beta.bar.cs
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
# l2.cs = sqrt(crossprod(beta.bar.cs))
# dist.t.cs = sqrt(sum((beta.bar.cs - beta.paper)^2))
# l2.cs
# dist.t.cs
yhat = beta.bar.cs0 + Xmat.cs %*% beta.bar.cs
xyrange = range(y, yhat)
plot(main = "with int, std.", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
#
beta.bar.cs2 = beta.bar.cs / x.sd
beta.bar.cs2
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs02
# sum(beta.bar.cs02, beta.bar.cs2)
# beta.bar.cs2 = beta.bar.cs2[-c(5, 6)]
# sum(beta.bar.cs2) # not satisfied anymore
# l2.cs2 = sqrt(crossprod(beta.bar.cs2))
# dist.t.cs2 = sqrt(sum((beta.bar.cs2 - beta.paper)^2))
# l2.cs2
# dist.t.cs2
yhat = beta.bar.cs02 + Xmat.cs %*% beta.bar.cs2
xyrange = range(y, yhat)
plot(main = "with in, back-std.", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# workdir = "/home/kristyn/Documents/research/supervisedlogratios/LogRatioReg"
# setwd(workdir)
# libraries
library(mvtnorm)
library(balance)
library(selbal)
library(microbenchmark)
library(ggplot2)
library(logratiolasso) # bates & tibshirani 2019
# Dr. Ma sources
source("RCode/func_libs.R")
source("COAT-master/coat.R")
# Kristyn sources
functions_path = "Kristyn/Functions/"
source(paste0(functions_path, "classic_lasso.R"))
source(paste0(functions_path, "compositional_lasso.R"))
source(paste0(functions_path, "supervisedlogratios.R"))
source(paste0(functions_path, "coat.R"))
source(paste0(functions_path, "principlebalances.R"))
source(paste0(functions_path, "selbal.R"))
# data
# 98 samples, 87 genera
# replace zero counts with 0.5 (maximum rounding error)
DataFolder <- "/Data/"
load(paste0("Data/", "BMI.rda"))
log.X.prop = log(X.prop)
# dim(raw_data) # 98 x 89
# dim(X) # 98 x 87
# dim(X.prop) # 98 x 87
n = dim(X)[1]
num.genera = dim(X)[2]
# testing with centered and/or scaled y
# y = scale(y, center = T, scale = T)
# try removing the 5 obese observations
sort(y)
sort(scale(y))
# they have BMI (y) > 36
# include = y < 36
# # checking if rows still sum to 1
# apply(X.prop, MARGIN = 1, sum)
# X = X[include, ]
# X.prop = X.prop[include, ]
# apply(X.prop, MARGIN = 1, sum)
# log.X.prop = log.X.prop[include, ]
# y = y[include]
final.selected = c(
"Bacteria.Bacteroidetes.Bacteroidia.Bacteroidales.Rikenellaceae.Alistipes",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Clostridiaceae.Clostridium",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Acidaminococcus",
"Bacteria.Firmicutes.Clostridia.Clostridiales.Veillonellaceae.Allisonella")
beta.paper = c(-0.76, -1.35, 0.61, 1.50)
################################################################################
# CONSTRAINED LINEAR MODEL
################################################################################
par(mfrow = c(2, 3))
# constrained - no centering or scaling:
# beta-bar = beta-hat - (X'X)^(-1) 1 [1' (X'X)^(-1) 1]^(-1) (1' beta-hat)
Xmat = log.X.prop[, final.selected]
beta.hat = solve(crossprod(Xmat), crossprod(Xmat, y))
# check that it matches lm() #
beta.hat.lm = coefficients(lm(y ~ -1 + Xmat))
all.equal(as.numeric(beta.hat), as.numeric(beta.hat.lm)) # they match, as expected
# compute beta.bar, constrained fit
Q = as.matrix(rep(1, dim(Xmat)[2]))
beta.bar = beta.hat - solve(crossprod(Xmat), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat), Q)), crossprod(Q, beta.hat))
sum(beta.bar)
beta.bar
l2 = sqrt(crossprod(beta.bar))
dist.t = sqrt(sum((beta.bar - beta.paper)^2))
l2
dist.t
yhat = Xmat %*% beta.bar
xyrange = range(y, yhat)
plot(main = "no intercept", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - scaling
x.sd = apply(Xmat,2,sd)
Xmat.s = scale(Xmat, center=F, scale=x.sd)
beta.hat.s = solve(crossprod(Xmat.s), crossprod(Xmat.s, y))
beta.bar.s = beta.hat.s - solve(crossprod(Xmat.s), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.s), Q)), crossprod(Q, beta.hat.s))
sum(beta.bar.s)
beta.bar.s
l2.s = sqrt(crossprod(beta.bar.s))
dist.t.s = sqrt(sum((beta.bar.s - beta.paper)^2))
l2.s
dist.t.s
yhat = Xmat.s %*% beta.bar.s
xyrange = range(y, yhat)
plot(main = "no int, scaled", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# back-scale
beta.bar.s2 = beta.bar.s / x.sd
sum(beta.bar.s2) # not satisfied anymore
beta.bar.s2
l2.s2 = sqrt(crossprod(beta.bar.s2))
dist.t.s2 = sqrt(sum((beta.bar.s2 - beta.paper)^2))
l2.s2
dist.t.s2
yhat = Xmat.s %*% beta.bar.s2
xyrange = range(y, yhat)
plot(main = "no int, back-scaled", x = y, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - with intercept
y.mean = mean(y)
y.c = y - y.mean
x.mean = colMeans(Xmat)
Xmat.c = scale(Xmat, center=x.mean, scale=F)
beta.hat.c = solve(crossprod(Xmat.c), crossprod(Xmat.c, y.c))
# check that it matches lm() #
beta.hat.lmint = coefficients(lm(y ~ Xmat))
# coefficients when centering match when not-centering (just not intercept, since centering gets rid of intercept)
all.equal(as.numeric(coefficients(lm(y ~ Xmat))[-1]),
as.numeric(coefficients(lm(y.c ~ Xmat.c))[-1]))
all.equal(as.numeric(beta.hat.c), as.numeric(beta.hat.lmint)[-1]) # they match, as expected
beta.hat.lmint0 = y.mean - as.vector(x.mean%*%beta.hat.c) # also match
# compute beta.bar, constrained fit
beta.bar.c = beta.hat.c - solve(crossprod(Xmat.c), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.c), Q)), crossprod(Q, beta.hat.c))
sum(beta.bar.c)
beta.bar.c
beta.bar.c0 <- y.mean - as.vector(x.mean%*%beta.bar.c)
# constrained - with intercept, including in Xmat
Xmat.c2 = cbind(1, Xmat)
beta.hat.c2 = solve(crossprod(Xmat.c2), crossprod(Xmat.c2, y))
Q2 = c(0, as.matrix(rep(1, dim(Xmat)[2])))
beta.bar.c2 = beta.hat.c2 - solve(crossprod(Xmat.c2), Q2) %*%
solve(crossprod(Q2, solve(crossprod(Xmat.c2), Q2)), crossprod(Q2, beta.hat.c2))
sum(beta.bar.c2[-1])
beta.bar.c2
all.equal(c(beta.bar.c0, beta.bar.c), as.numeric(beta.bar.c2)) # this matches the above
l2.c = sqrt(crossprod(beta.bar.c))
dist.t.c = sqrt(sum((beta.bar.c - beta.paper)^2))
l2.c
dist.t.c
yhat = beta.bar.c0 + Xmat.c %*% beta.bar.c
xyrange = range(y, yhat)
plot(main = "with intercept", x = y.c, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
xyrange = range(y.c, yhat)
plot(main = "with intercept", x = y.c, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
# constrained - with intercept and scaling (standardizing, bc need to center for intercept)
Xmat.cs = scale(Xmat, center=x.mean, scale=x.sd)
beta.hat.cs = solve(crossprod(Xmat.cs), crossprod(Xmat.cs, y.c))
beta.bar.cs = beta.hat.cs - solve(crossprod(Xmat.cs), Q) %*%
solve(crossprod(Q, solve(crossprod(Xmat.cs), Q)), crossprod(Q, beta.hat.cs))
sum(beta.bar.cs)
beta.bar.cs
beta.bar.cs0 <- y.mean - as.vector(x.mean%*%beta.bar.cs)
beta.bar.cs0
l2.cs = sqrt(crossprod(beta.bar.cs))
dist.t.cs = sqrt(sum((beta.bar.cs - beta.paper)^2))
l2.cs
dist.t.cs
yhat = beta.bar.cs0 + Xmat.cs %*% beta.bar.cs
xyrange = range(y.c, yhat)
plot(main = "with int, std.", x = y.c, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
#
beta.bar.cs2 = beta.bar.cs / x.sd
beta.bar.cs2
sum(beta.bar.cs2) # not satisfied anymore
beta.bar.cs02 <- y.mean - as.vector(x.mean%*%beta.bar.cs2)
beta.bar.cs02
sum(beta.bar.cs02, beta.bar.cs2)
sum(beta.bar.cs2) # not satisfied anymore
l2.cs2 = sqrt(crossprod(beta.bar.cs2))
dist.t.cs2 = sqrt(sum((beta.bar.cs2 - beta.paper)^2))
l2.cs2
dist.t.cs2
yhat = beta.bar.cs02 + Xmat.cs %*% beta.bar.cs2
xyrange = range(y.c, yhat)
plot(main = "with in, back-std.", x = y.c, y = yhat, xlim = xyrange, ylim = xyrange); abline(0, 1, lty = 2)
