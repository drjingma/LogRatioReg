---
title: "Two step sims"
output: html_notebook
---

```{r}
library(glmnet)
library(ggplot2)
library(gridExtra)
library(grid)
library(MASS)
library(leaps)
library(dplyr)
library(magrittr)


source("two_step.r")
source("two_step_cv.r")
source("logRatioLasso.R")
source("approximate_fs.r")
source("cv_fs.r")
```

Here we test out procedure using forward-stepwise regression and the constrained lasso.  We compare the procedure that use $y$ to the procedure using $\hat{y}$ in the second stage.

We compare this to vanilla lasso.

```{r}
n <- 100
p <- 30
beta <- c(2,-2,1,-1,rep(0,p-4))
sig <- 2
lambda_1 <- exp(0:-12 / 2)
c <- 0

sigma <- autoRegressiveCorr(p, c)
X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
x <- X
z <- log(X)
y <- z %*% beta * sig + rnorm(n)
y <- y - mean(y)
z <- scale(z, center = TRUE, scale = FALSE)
```

```{r}
two_step_wrapper <- function(z, y, k_max = 5, lambda_1 = NULL, ...) {
  #return cv minimizer for the two-step procedure
  fit <- cv_two_step_generic(z, y, k_max = k_max, lambda_1 = lambda_1, ...)
  return(fit$beta_min)
}

fit$beta_min
fit <- cv_two_step_generic(z, y, k_max = k_max, lambda_1 = lambda_1,
                           second.stage = "yhat")
two_step_wrapper(z, y, k_max = 5, lambda_1 = lambda_1, second.stage = "yhat")
```

```{r}
lasso_wrapper <- function(z, y) {
  fit <- cv.glmnet(z, y, lambda = lambda_1, intercept = FALSE, standardize = FALSE)
  return(coef(fit, s = "lambda.min")[-1])
}

a <- lasso_wrapper(z, y, lambda_1)
a
```

```{r}
constrained_lasso_wrapper <- function(z, y, lambda_1 = lambda_1) {
  fit <- glmnet.constr(z,y)
  cv <- cv.glmnet.constr(fit, z, y)
  best <- which.min(cv$cvm)
  fit$beta[,best]
}

constrained_lasso_wrapper(z, y, lambda_1)
```

```{r}
ridge_wrapper <- function(z, y, lambda_1) {
  fit <- cv.glmnet(z, y, lambda = lambda_1, intercept = FALSE, standardize = FALSE, alpha = 0)
  return(coef(fit, s = "lambda.min")[-1])
}

ridge_wrapper(z, y, lambda_1)
```

```{r}
approx_fs_wrapper <- function(z, y) {
  fit <- cv.approximate_fs(z, y, k_max = 8, n_folds = 5)
  return(fit$beta)
}

approx_fs_wrapper(z,y)
```

```{r}
lambda_1 <- exp(0:-12 / 2)

get_instance <- function(n, p, beta, sig) {
  c <- 0
  sigma <- autoRegressiveCorr(p, c)
  X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
  x <- X
  z <- log(X)
  y <- z %*% beta * sig + rnorm(n)
  y <- y - mean(y)
  z <- scale(z, center = TRUE, scale = FALSE)
  
  cbind(two_step_wrapper(z, y, k_max = k_max, lambda_1 = lambda_1),
        two_step_wrapper(z, y, k_max = k_max, lambda_1 = lambda_1, second.stage = "yhat"),
        lasso_wrapper(z, y, lambda_1),
        constrained_lasso_wrapper(z, y, lambda_1),
        ridge_wrapper(z, y, lambda_1),
        approx_fs_wrapper(z, y)
        )
}
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
set.seed(100)
N_sim <- 2
big_results <- replicate(N_sim, get_instance(n, p, beta, sig))
dim(big_results)
```

## The simulation (depricated)

* n = 100
* p = 30
two signals: size 1 and 2
varying signal strength

### simulation parameters

```{r}
n <- 100
p <- 30
beta <- c(2,-2,1,-1,rep(0,p-4))
signal_seq <- c(3,2,1.5,1,.75,.5,.3,.2)
```

What is the detection regime?

```{r}
wrapper <- function(){
  c <- .8
  sigma <- autoRegressiveCorr(p, c)
  X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
  x <- X
  z <- log(X)
  y <- rnorm(n)
  y <- y - mean(y)
  z <- scale(z, center = TRUE, scale = FALSE)

  max(abs(coef(lm(y~z))))
}

max_noise <- replicate(500, wrapper())
quantile(max_noise)
```

The largest null signal in a linear model is roughtly of size .25

#### run simulation

```{r message=FALSE, warning=FALSE, include=FALSE}
big_results <- list()
N_sim <- 200

Sys.time()
for(signal in signal_seq) {
  results <- replicate(N_sim, get_instance(n, p, beta, signal))
  big_results[[paste0("sig-",signal)]] <- results
  print(paste0("completed:", signal," at ", Sys.time()))
}
```

```{r}
#save(big_results, file = "sims/two_signal2.RData")
load("sims/two_signal2.RData")
```

#### Process the results

```{r}
bias <- function(beta_hat, signal){
  rowMeans(beta_hat - signal*beta)
}

mse <- function(beta_hat, signal){
  mean(apply(beta_hat - signal*beta, 2, two_norm))
}
```

```{r}
agg_results <- data.frame()
for(signal in signal_seq) {
  bias_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){bias(x, signal)})
  bias_sq <- apply(bias_temp, 2, two_norm)
  mse_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){mse(x, signal)})
  print(mse_temp)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-step-debiased",
                                         "bias_sq" = bias_sq[1], "mse" = mse_temp[1]),
                                          stringsAsFactors = FALSE)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-step",
                                         "bias_sq" = bias_sq[2], "mse" = mse_temp[2]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "vanilla-lasso",
                                         "bias_sq" = bias_sq[3], "mse" = mse_temp[3]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "constrained-lasso",
                                         "bias_sq" = bias_sq[4], "mse" = mse_temp[4]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "ridge",
                                         "bias_sq" = bias_sq[5], "mse" = mse_temp[5]))
}

agg_results$var <- agg_results$mse - agg_results$bias_sq
```


## Two strong signals (current)

Now we look at the model with one log signal that has coef .5.

```{r}
n <- 100
p <- 30
beta <- c(2,-2,1,-1,rep(0,p-4))
sig <- 2
lambda_1 <- exp(0:-18 / 2)
```

```{r}
two_step_wrapper <- function(z, y, k_max = 5, lambda_1 = NULL, ...) {
  #return cv minimizer for the two-step procedure
  fit <- cv_two_step_generic(z, y, k_max = k_max, lambda_1 = lambda_1, ...)
  return(fit$beta_min)
}

two_step_mse <- function(z, y, k_max = 5, lambda_1 = NULL, ...) {
  #return cv minimizer for the two-step procedure
  fit <- cv_two_step_generic(z, y, k_max = k_max, lambda_1 = lambda_1, ...)
  return(min(fit$mse))
}

fit$beta_min
fit <- cv_two_step_generic(z, y, k_max = k_max, lambda_1 = lambda_1, second.stage = "yhat")
two_step_wrapper(z, y, k_max = 5, lambda_1 = lambda_1, second.stage = "yhat")
```

```{r}
lasso_wrapper <- function(z, y, lambda_1 = lambda_1) {
  fit <- cv.glmnet(z, y, lambda = lambda_1, intercept = FALSE, standardize = FALSE)
  return(coef(fit, s = "lambda.min")[-1])
}

lasso_mse <- function(z, y, lambda_1 = lambda_1) {
  fit <- cv.glmnet(z, y, lambda = lambda_1, intercept = FALSE, standardize = FALSE)
  return(fit$cvm[which(fit$lambda==fit$lambda.min)])
}

a <- lasso_wrapper(z, y, lambda_1)
a
```

```{r}
constrained_lasso_wrapper <- function(z, y, lambda_1 = lambda_1) {
  fit <- glmnet.constr(z,y, lambda =  lambda_1)
  cv <- cv.glmnet.constr(fit, z, y)
  best <- which.min(cv$cvm)
  fit$beta[,best]
}

constrained_lasso_wrapper(z, y, lambda_1)
```

```{r}
ridge_wrapper <- function(z, y, lambda_1) {
  fit <- cv.glmnet(z, y, lambda = lambda_1, intercept = FALSE, standardize = FALSE, alpha = 0)
  return(coef(fit, s = "lambda.min")[-1])
}

ridge_wrapper(z, y, lambda_1)
```

```{r}
approx_fs_wrapper <- function(z, y) {
  fit <- cv.approximate_fs(z, y, k_max = 8, n_folds = 5)
  return(fit$beta)
}

approx_fs_wrapper(z,y)

fs_wrapper <- function(z, y) {
  fit <- cv.fs(z, y, k_max = 8, n_folds = 5)
  return(fit$beta)
}

fs_wrapper(z,y)
```

```{r}
#lambda_1 <- exp(0:-12 / 2)

get_instance <- function(n, p, beta, sig, c=0) {
  c <- 0
  sigma <- autoRegressiveCorr(p, c)
  X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
  x <- X
  z <- log(X)
  z <- scale(z, center = TRUE, scale = FALSE)
  y <- z %*% beta * sig + rnorm(n) 
#  y <- y + .3 * z[, 5] #miscpecified term

  cbind(two_step_wrapper(z, y, k_max = k_max, lambda_1 = lambda_1),
        two_step_wrapper(z, y, k_max = k_max, lambda_1 = lambda_1, second.stage = "yhat"),
        lasso_wrapper(z, y, lambda_1),
        constrained_lasso_wrapper(z, y, lambda_1),
        ridge_wrapper(z, y, lambda_1),
        approx_fs_wrapper(z, y),
        fs_wrapper(z,y)
        )
}

get_mse_instance <- function(n, p, beta, sig) {
  c <- 0
  sigma <- autoRegressiveCorr(p, c)
  X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
  x <- X
  z <- log(X)
  y <- z %*% beta * sig + rnorm(n) + .3 * z[,5]
  y <- y - mean(y)
  z <- scale(z, center = TRUE, scale = FALSE)
  
  cbind(two_step_mse(z, y, k_max = k_max, lambda_1 = lambda_1),
        two_step_mse(z, y, k_max = k_max, lambda_1 = lambda_1, second.stage = "yhat"),
        lasso_mse(z, y, lambda_1)
        )
}
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
set.seed(100)
N_sim <- 2
big_results <- replicate(N_sim, get_instance(n, p, beta, sig))
dim(big_results)
```

### The simulation

* n = 100
* p = 30
two signals: size 1 and 2
varying signal strength


#### simulation parameters

```{r}
n <- 100
p <- 30
beta <- c(2,-2,1,-1,rep(0,p-4))
signal_seq <- c(3,2.5,2,1.5,1,.75,.5,.4,.3)
```

What is the detection regime?

```{r}
wrapper <- function(){
  c <- 0
  sigma <- autoRegressiveCorr(p, c)
  X  <- abs(mvrnorm(n = n, rep(0, p), sigma))
  x <- X
  z <- log(X)
  y <- rnorm(n)
  y <- y - mean(y)
  z <- scale(z, center = TRUE, scale = FALSE)

  max(abs(coef(lm(y~z))))
}

max_noise <- replicate(500, wrapper())
quantile(max_noise)
```

The largest null signal in a linear model is roughtly of size .25

#### run simulation

```{r message=FALSE, warning=FALSE, include=FALSE}
beta <- c(2,-2,1,-1,rep(0,p-4))

big_results <- list()
N_sim <- 200
signal_seq <- c(.2,.1)

Sys.time()
for(signal in signal_seq) {
  results <- replicate(N_sim, get_instance(n, p, beta, signal))
  big_results[[paste0("sig-",signal)]] <- results
  print(paste0("completed:", signal," at ", Sys.time()))
}
```

```{r}
#save(big_results, file = "sims/two_signal_big_v3_v2.RData")
load("sims/two_signal_mispecified_v2.RData")
```

current files (8/23/2017)
"two_signal_big_v2.RData"
"two_signal_mispecified_v2"
"two_signal_big_v3"
"two_signal_big_v3_2"
"two_signal_big_v4"
"unnattached_spike"

#### Process the results

```{r}
bias <- function(beta_hat, signal){
  true_beta <- signal * beta
  true_beta[5] <- .3
  rowMeans(beta_hat - true_beta)
}

mse <- function(beta_hat, signal){
  true_beta <- signal * beta
  true_beta[5] <- .3
  mean(apply(beta_hat - true_beta, 2, two_norm))
}
```

```{r}
beta <- c(2,-2,1,-1,rep(0,p-4))
agg_results <- data.frame()
signal_seq <- c(3,2,1.5,1,.75,.5,.3,.2,.1)
#signal_seq <- c(3,2.5,2,1.5,1,.75,.5,.4,.3,.2,.1)
for(signal in signal_seq) {
  bias_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){bias(x, signal)})
  bias_sq <- apply(bias_temp, 2, two_norm)
  mse_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){mse(x, signal)})
  print(mse_temp)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage",
                                         "bias_sq" = bias_sq[1], "mse" = mse_temp[1]),
                                          stringsAsFactors = FALSE)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage-conservative",
                                         "bias_sq" = bias_sq[2], "mse" = mse_temp[2]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "vanilla-lasso",
                                         "bias_sq" = bias_sq[3], "mse" = mse_temp[3]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "single-stage",
                                         "bias_sq" = bias_sq[4], "mse" = mse_temp[4]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "ridge",
                                         "bias_sq" = bias_sq[5], "mse" = mse_temp[5]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "approx-fs",
                                         "bias_sq" = bias_sq[6], "mse" = mse_temp[6]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "fs",
                                         "bias_sq" = bias_sq[7], "mse" = mse_temp[7]))
}

agg_results$var <- agg_results$mse - agg_results$bias_sq
```

```{r}
#write.csv(agg_results, file = "sims/two_signal_processed_small.csv")
```

```{r}
signal_plot <- ggplot(agg_results, aes(x = signal, y = mse, color = method)) +
  geom_line() + 
  labs(x = "signal strength", y = "MSE")
signal_plot

bias_plot <- ggplot(agg_results, aes(x = signal, y = bias_sq, color = method)) +
  geom_line() +
  labs(x = "signal strength", y = "bias squared")
bias_plot

var_plot <- ggplot(agg_results, aes(x = signal, y = var, color = method)) +
  geom_line() + 
  labs(x = "signal strength", y = "variance")
var_plot

#save(signal_plot, bias_plot, var_plot, file = "sims/two_signal_raw_plots.RData")

combined_plot <- grid.arrange(signal_plot, bias_plot, var_plot, nrow = 3)
combined_plot
```

```{r}
   ggsave(plot = combined_plot, filename = "plots/two_signal_combined_v2.pdf",
             device = "pdf", scale = 1.5)
```

Recovery of support

```{r}
large_signal <- function(beta_hat) {
  mean(beta_hat[1:2, ] != 0)
}

small_signal <- function(beta_hat) {
  mean(beta_hat[3:4, ] != 0)
}

nulls <- function(beta_hat) {
  mean(beta_hat[5:ncol(beta_hat), ] != 0)
  mean(beat_hat[6:ncol(beta_hat), ] != 0)
}
```

```{r}
recovery_results <- data.frame()
for(signal in signal_seq) {
  large_temp <- apply(big_results[[paste0("sig-",signal)]][1:2,,], 2,
                function(x){mean(x != 0)})
  small_temp <- apply(big_results[[paste0("sig-",signal)]][3:4,,], 2,
                function(x){mean(x != 0)})
  null_temp <- apply(big_results[[paste0("sig-",signal)]][5:p,,], 2,
                function(x){mean(x != 0)})
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage",
                                         "large_sig" = large_temp[1], "small_sig" = small_temp[1],
                                          "nulls" = null_temp[1]),
                                          stringsAsFactors = FALSE)
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage-conservative",
                                         "large_sig" = large_temp[2], "small_sig" = small_temp[2],
                                          "nulls" = null_temp[2]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "vanilla-lasso",                                                             "large_sig" = large_temp[3], "small_sig" = small_temp[3],
                                          "nulls" = null_temp[3]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "single-stage",                                                             "large_sig" = large_temp[4], "small_sig" = small_temp[4],
                                          "nulls" = null_temp[4]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "approx-fs",                                                             "large_sig" = large_temp[6], "small_sig" = small_temp[6],
                                          "nulls" = null_temp[6]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "fs",                                                             "large_sig" = large_temp[7], "small_sig" = small_temp[7],
                                          "nulls" = null_temp[7]))


                                        
}
```

```{r}
large_plot <- ggplot(recovery_results, aes(x = signal, y = large_sig, color = method)) +
  geom_line() + 
  labs(x = "signal strength", y = "large signal recovery")
large_plot

small_plot <- ggplot(recovery_results, aes(x = signal, y = small_sig, color = method)) +
  geom_line() + 
  labs(x = "signal strength", y = "small signal recovery")

null_plot <- ggplot(recovery_results, aes(x = signal, y = nulls, color = method)) +
  geom_line() +
  labs(x = "signal strength", y = "nulls selected")
null_plot

#save(large_plot, small_plot, null_plot, file = "sims/two_signal_raw_plots_rec.RData")

combined_plot <- grid.arrange(large_plot, small_plot, null_plot, nrow = 3)
combined_plot
```

```{r}
# ggsave(combined_plot, filename = "plots/two_signal_recovery_v2.pdf",
#        device = "pdf", scale = 1.5)
```

### MSE CV estimation

How well does the two-step procedure CV error match the MSE?

```{r message=FALSE, warning=FALSE, include=FALSE}
mse_results <- list()
N_sim <- 50

Sys.time()
for(signal in signal_seq) {
  results <- replicate(N_sim, get_mse_instance(n, p, beta, signal))
  mse_results[[paste0("sig-",signal)]] <- results
  print(paste0("completed:", signal," at ", Sys.time()))
}
```

```{r}
signal_seq <- c(3,2,1,.75,.5,.3,.2)
for(signal in signal_seq) {
  mse_temp <- apply(mse_results[[paste0("sig-",signal)]], 2, mean)
  
  agg_results <- rbind(agg_results, list("signal" = signal, "method" = "cv_two-step-debiased",
                                         "mse" = mse_temp[1] - 1, "bias_sq" = NA, "var" = NA),
                                          stringsAsFactors = FALSE)
  agg_results <- rbind(agg_results, list("signal" = signal, "method" = "cv_two-step",
                                        "mse" = mse_temp[2] - 1, "bias_sq" = NA, "var" = NA))
  agg_results <- rbind(agg_results, list("signal" = signal, "method" = "cv_vanilla-lasso",
                                        "mse" = mse_temp[3] - 1, "bias_sq" = NA, "var" = NA))
}
```

```{r}
plot_dat <- agg_results %>% 
  filter(method != "rdige") %>%
  filter(method != "constrained-lasso")
  
signal_plot <- ggplot(plot_dat, aes(x = signal, y = mse, color = method)) +
  geom_line() + 
  labs(x = "signal strength", y = "MSE")
signal_plot
```


## Joint MSE and Signal recovery plots

It takes a bit of work to give all of the plots the same color scheme and a shared legend.

```{r}
#extract ggplot colors
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
colors <- gg_color_hue(6)
colors <- c("#000000", colors)
colors <- colors[c(3,2,5,4,6,1,7)]

signal_plot <- ggplot(agg_results, aes(x = signal, y = mse, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "MSE") 
signal_plot

bias_plot <- ggplot(agg_results, aes(x = signal, y = bias_sq, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() +
  labs(x = "Signal strength", y = "Bias squared")
bias_plot

var_plot <- ggplot(agg_results, aes(x = signal, y = var, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "Variance")
var_plot

large_plot <- ggplot(recovery_results, aes(x = signal, y = large_sig, color = method)) +
  scale_colour_manual(values = colors[-3]) +
  geom_line() + 
  labs(x = "Signal strength", y = "Large signal recovery") +
  scale_x_continuous(limits = c(.1,1))
large_plot

small_plot <- ggplot(recovery_results, aes(x = signal, y = small_sig, color = method)) +
  geom_line() + 
  scale_colour_manual(values = colors[-3]) +
  labs(x = "Signal strength", y = "Small signal recovery") + 
  scale_x_continuous(limits = c(.1,1))
small_plot

null_plot <- ggplot(recovery_results, aes(x = signal, y = nulls, color = method)) +
  geom_line() +
  scale_colour_manual(values = colors[-3]) +
  labs(x = "Signal strength", y = "Nulls selected")
null_plot



```


```{r}
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {

  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position="none"))
  gl <- c(gl, ncol = ncol, nrow = nrow)

  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))

  grid.newpage()
  grid.draw(combined)

  # return gtable invisibly
  invisible(combined)

}




```

```{r}
full_plot <- grid_arrange_shared_legend(signal_plot, bias_plot, var_plot, 
                           large_plot, small_plot, null_plot, 
                           ncol = 3, nrow = 2)
full_plot
```
```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_full_grid.pdf", device = "pdf", width = 6, height = 4, units = "in")
```

```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid.pdf", device = "pdf", width = 6, height = 4, units = "in")
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid.eps", device = "eps", width = 6, height = 4, units = "in")
```




## Mispec plotting

```{r}
load("sims/two_signal_mispecified_v2.RData")
```


```{r}
bias <- function(beta_hat, signal){
  true_beta <- signal * beta
  true_beta[5] <- .3
  rowMeans(beta_hat - true_beta)
}

mse <- function(beta_hat, signal){
  true_beta <- signal * beta
  true_beta[5] <- .3
  mean(apply(beta_hat - true_beta, 2, two_norm))
}
```

```{r}
beta <- c(2,-2,1,-1,rep(0,p-4))
agg_results <- data.frame()
signal_seq <- c(3,2,1.5,1,.75,.5,.3,.2,.1)
#signal_seq <- c(3,2.5,2,1.5,1,.75,.5,.4,.3,.2,.1)
for(signal in signal_seq) {
  bias_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){bias(x, signal)})
  bias_sq <- apply(bias_temp, 2, two_norm)
  mse_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){mse(x, signal)})
  print(mse_temp)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage",
                                         "bias_sq" = bias_sq[1], "mse" = mse_temp[1]),
                                          stringsAsFactors = FALSE)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage-conservative",
                                         "bias_sq" = bias_sq[2], "mse" = mse_temp[2]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "vanilla-lasso",
                                         "bias_sq" = bias_sq[3], "mse" = mse_temp[3]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "single-stage",
                                         "bias_sq" = bias_sq[4], "mse" = mse_temp[4]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "ridge",
                                         "bias_sq" = bias_sq[5], "mse" = mse_temp[5]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "approx-fs",
                                         "bias_sq" = bias_sq[6], "mse" = mse_temp[6]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "fs",
                                         "bias_sq" = bias_sq[7], "mse" = mse_temp[7]))
}

agg_results$var <- agg_results$mse - agg_results$bias_sq
```

```{r}
large_signal <- function(beta_hat) {
  mean(beta_hat[1:2, ] != 0)
}

small_signal <- function(beta_hat) {
  mean(beta_hat[3:4, ] != 0)
}

nulls <- function(beta_hat) {
  mean(beat_hat[6:ncol(beta_hat), ] != 0)
}
```

```{r}
recovery_results <- data.frame()
for(signal in signal_seq) {
  large_temp <- apply(big_results[[paste0("sig-",signal)]][1:2,,], 2,
                function(x){mean(x != 0)})
  small_temp <- apply(big_results[[paste0("sig-",signal)]][3:4,,], 2,
                function(x){mean(x != 0)})
  null_temp <- apply(big_results[[paste0("sig-",signal)]][5:p,,], 2,
                function(x){mean(x != 0)})
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage",
                                         "large_sig" = large_temp[1], "small_sig" = small_temp[1],
                                          "nulls" = null_temp[1]),
                                          stringsAsFactors = FALSE)
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage-conservative",
                                         "large_sig" = large_temp[2], "small_sig" = small_temp[2],
                                          "nulls" = null_temp[2]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "vanilla-lasso",                                                             "large_sig" = large_temp[3], "small_sig" = small_temp[3],
                                          "nulls" = null_temp[3]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "single-stage",                                                             "large_sig" = large_temp[4], "small_sig" = small_temp[4],
                                          "nulls" = null_temp[4]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "approx-fs",                                                             "large_sig" = large_temp[6], "small_sig" = small_temp[6],
                                          "nulls" = null_temp[6]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "fs",                                                             "large_sig" = large_temp[7], "small_sig" = small_temp[7],
                                          "nulls" = null_temp[7]))


                                        
}
```

```{r}
#extract ggplot colors
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 70, c = 100)[1:n]
}

colors <- gg_color_hue(6)
colors <- c("#000000", colors)
colors <- colors[c(3,2,5,4,6,1,7)]
recov_colors <- colors[-3]
```

```{r}
#filter the data to exclude two-stage-conservative and ridge regression
methods <- c("single-stage", "two-stage", "vanilla-lasso", "approx-fs", "fs")
recovery_results %<>% filter(method %in% methods)
agg_results %<>% filter(method %in% methods)

colors <- gg_color_hue(4)
colors <- c("#000000", colors)
colors <- c("blue","green","orange","red","black")
recov_colors <- colors
```

```{r}
signal_plot <- ggplot(agg_results, aes(x = signal, y = mse, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "MSE") 
signal_plot

bias_plot <- ggplot(agg_results, aes(x = signal, y = bias_sq, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() +
  labs(x = "Signal strength", y = "Bias squared")
bias_plot

var_plot <- ggplot(agg_results, aes(x = signal, y = var, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "Variance")
var_plot

large_plot <- ggplot(recovery_results, aes(x = signal, y = large_sig, color = method)) +
  scale_colour_manual(values = recov_colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "Large signal recovery") +
  scale_x_continuous(limits = c(.1,1))
large_plot

small_plot <- ggplot(recovery_results, aes(x = signal, y = small_sig, color = method)) +
  geom_line() + 
  scale_colour_manual(values = recov_colors) +
  labs(x = "Signal strength", y = "Small signal recovery") + 
  scale_x_continuous(limits = c(.1,1))
small_plot

null_plot <- ggplot(recovery_results, aes(x = signal, y = nulls, color = method)) +
  geom_line() +
  scale_colour_manual(values = recov_colors) +
  labs(x = "Signal strength", y = "Nulls selected")
null_plot



```


```{r}
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {

  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position="none"))
  gl <- c(gl, ncol = ncol, nrow = nrow)

  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))

  grid.newpage()
  grid.draw(combined)

  # return gtable invisibly
  invisible(combined)

}




```

```{r}
full_plot <- grid_arrange_shared_legend(signal_plot, bias_plot, var_plot, 
                           large_plot, small_plot, null_plot, 
                           ncol = 2, nrow = 3)
full_plot
```

```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid.pdf", device = "pdf", width = 5.5, height = 4, units = "in")
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid.eps", device = "eps", width = 5.5, height = 4, units = "in")
```

```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid_reduced.pdf", device = "pdf", width = 5.5, height = 8, units = "in")
ggsave(plot = full_plot, filename = "plots/two_signal_mispecified_full_grid_reduced.eps", device = "eps", width = 5.5, height = 8, units = "in")
```


## normal plotting

```{r}
load("sims/two_signal_big_v4.RData")
```


```{r}
bias <- function(beta_hat, signal){
  true_beta <- signal * beta
  rowMeans(beta_hat - true_beta)
}

mse <- function(beta_hat, signal){
  true_beta <- signal * beta
  mean(apply(beta_hat - true_beta, 2, two_norm))
}
```

```{r}
beta <- c(2,-2,1,-1,rep(0,p-4))
agg_results <- data.frame()
#signal_seq <- c(3,2,1.5,1,.75,.5,.3,.2,.1)
signal_seq <- c(3,2.5,2,1.5,1,.75,.5,.4,.3,.2,.1)
for(signal in signal_seq) {
  bias_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){bias(x, signal)})
  bias_sq <- apply(bias_temp, 2, two_norm)
  mse_temp <- apply(big_results[[paste0("sig-",signal)]], 2,
                function(x){mse(x, signal)})
  print(mse_temp)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage",
                                         "bias_sq" = bias_sq[1], "mse" = mse_temp[1]),
                                          stringsAsFactors = FALSE)
  agg_results <- rbind(agg_results, list("signal" = signal, method = "two-stage-conservative",
                                         "bias_sq" = bias_sq[2], "mse" = mse_temp[2]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "vanilla-lasso",
                                         "bias_sq" = bias_sq[3], "mse" = mse_temp[3]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "single-stage",
                                         "bias_sq" = bias_sq[4], "mse" = mse_temp[4]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "ridge",
                                         "bias_sq" = bias_sq[5], "mse" = mse_temp[5]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "approx-fs",
                                         "bias_sq" = bias_sq[6], "mse" = mse_temp[6]))
  agg_results <- rbind(agg_results, list("signal" = signal, method = "fs",
                                         "bias_sq" = bias_sq[7], "mse" = mse_temp[7]))
}

agg_results$var <- agg_results$mse - agg_results$bias_sq
```

```{r}
large_signal <- function(beta_hat) {
  mean(beta_hat[1:2, ] != 0)
}

small_signal <- function(beta_hat) {
  mean(beta_hat[3:4, ] != 0)
}

nulls <- function(beta_hat) {
  mean(beat_hat[5:ncol(beta_hat), ] != 0)
}
```

```{r}
recovery_results <- data.frame()
for(signal in signal_seq) {
  large_temp <- apply(big_results[[paste0("sig-",signal)]][1:2,,], 2,
                function(x){mean(x != 0)})
  small_temp <- apply(big_results[[paste0("sig-",signal)]][3:4,,], 2,
                function(x){mean(x != 0)})
  null_temp <- apply(big_results[[paste0("sig-",signal)]][5:p,,], 2,
                function(x){mean(x != 0)})
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage",
                                         "large_sig" = large_temp[1], "small_sig" = small_temp[1],
                                          "nulls" = null_temp[1]),
                                          stringsAsFactors = FALSE)
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "two-stage-conservative",
                                         "large_sig" = large_temp[2], "small_sig" = small_temp[2],
                                          "nulls" = null_temp[2]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "vanilla-lasso",                                                             "large_sig" = large_temp[3], "small_sig" = small_temp[3],
                                          "nulls" = null_temp[3]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "single-stage",                                                             "large_sig" = large_temp[4], "small_sig" = small_temp[4],
                                          "nulls" = null_temp[4]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "approx-fs",                                                             "large_sig" = large_temp[6], "small_sig" = small_temp[6],
                                          "nulls" = null_temp[6]))
  recovery_results <- rbind(recovery_results, list("signal" = signal, method = "fs",                                                             "large_sig" = large_temp[7], "small_sig" = small_temp[7],
                                          "nulls" = null_temp[7]))


                                        
}
```

```{r}
#extract ggplot colors
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 70, c = 100)[1:n]
}

colors <- gg_color_hue(6)
colors <- c("#000000", colors)
colors <- colors[c(3,2,5,4,6,1,7)]
recov_colors <- colors[-3]
```

```{r}
#filter the data to exclude two-stage-conservative and ridge regression
methods <- c("single-stage", "two-stage", "vanilla-lasso", "approx-fs", "fs")
recovery_results %<>% filter(method %in% methods)
agg_results %<>% filter(method %in% methods)

colors <- gg_color_hue(4)
colors <- c("#000000", colors)
colors <- c("blue","green","orange","red","black")
recov_colors <- colors
```

```{r}
signal_plot <- ggplot(agg_results, aes(x = signal, y = mse, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "MSE") 
signal_plot

bias_plot <- ggplot(agg_results, aes(x = signal, y = bias_sq, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() +
  labs(x = "Signal strength", y = "Bias squared")
bias_plot

var_plot <- ggplot(agg_results, aes(x = signal, y = var, color = method)) +
  scale_colour_manual(values = colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "Variance")
var_plot

large_plot <- ggplot(recovery_results, aes(x = signal, y = large_sig, color = method)) +
  scale_colour_manual(values = recov_colors) +
  geom_line() + 
  labs(x = "Signal strength", y = "Large signal recovery") +
  scale_x_continuous(limits = c(.1,1))
large_plot

small_plot <- ggplot(recovery_results, aes(x = signal, y = small_sig, color = method)) +
  geom_line() + 
  scale_colour_manual(values = recov_colors) +
  labs(x = "Signal strength", y = "Small signal recovery") + 
  scale_x_continuous(limits = c(.1,1))
small_plot

null_plot <- ggplot(recovery_results, aes(x = signal, y = nulls, color = method)) +
  geom_line() +
  scale_colour_manual(values = recov_colors) +
  labs(x = "Signal strength", y = "Nulls selected")
null_plot



```


```{r}
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {

  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position="none"))
  gl <- c(gl, ncol = ncol, nrow = nrow)

  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))

  grid.newpage()
  grid.draw(combined)

  # return gtable invisibly
  invisible(combined)

}
```

```{r}
full_plot <- grid_arrange_shared_legend(signal_plot, bias_plot, var_plot, 
                           large_plot, small_plot, null_plot, 
                           ncol = 2, nrow = 3)
full_plot
```

```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_full_grid.pdf", device = "pdf", width = 5.5, height = 4, units = "in")
ggsave(plot = full_plot, filename = "plots/two_signal_full_grid.eps", device = "eps", width = 5.5, height = 4, units = "in")
```

```{r}
ggsave(plot = full_plot, filename = "plots/two_signal_full_grid_reduced.pdf", device = "pdf", width = 5.5, height = 8, units = "in")
ggsave(plot = full_plot, filename = "plots/two_signal_full_grid_reduced.eps", device = "eps", width = 5.5, height = 8, units = "in")
```
