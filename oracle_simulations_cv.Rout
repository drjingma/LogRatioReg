
R version 4.0.5 (2021-03-31) -- "Shake and Throw"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # last updated: 04/19/2021
> # oracle simulations from response generated by SigmaW tree
> 
> getwd()
[1] "/home/kristynp/Documents/LogRatioReg"
> output_dir = "Kristyn/Experiments/SigmaW_simulations/output"
> 
> # libraries
> library(mvtnorm)
> library(stats) # for hclust()
> library(balance) # for sbp.fromHclust()
> 
> # set up parallelization
> library(foreach)
> library(future)
> library(doFuture)
> library(parallel)
> registerDoFuture()
> nworkers = detectCores() - 2
> plan(multisession, workers = nworkers)
> 
> library(rngtools)
> library(doRNG)
> rng.seed = 123 # 123, 345
> registerDoRNG(rng.seed)
> 
> # Dr. Ma sources
> library(Matrix)
> library(glmnet)
Loaded glmnet 4.0-2
> library(compositions)
Welcome to compositions, a package for compositional data analysis.
Find an intro with "? compositions"


Attaching package: ‘compositions’

The following object is masked from ‘package:glmnet’:

    rmult

The following object is masked from ‘package:Matrix’:

    norm

The following object is masked from ‘package:balance’:

    balance

The following objects are masked from ‘package:stats’:

    cor, cov, dist, var

The following objects are masked from ‘package:base’:

    %*%, norm, scale, scale.default

> library(stats)
> source("RCode/func_libs.R")
gdata: read.xls support for 'XLS' (Excel 97-2004) files ENABLED.

gdata: Unable to load perl libaries needed by read.xls()
gdata: to support 'XLSX' (Excel 2007+) files.

gdata: Run the function 'installXLSXsupport()'
gdata: to automatically download and install the perl
gdata: libaries needed to support Excel XLS and XLSX formats.

Attaching package: ‘gdata’

The following object is masked from ‘package:stats’:

    nobs

The following object is masked from ‘package:utils’:

    object.size

The following object is masked from ‘package:base’:

    startsWith

> 
> # Kristyn sources
> functions_path = "Kristyn/Functions/"
> source(paste0(functions_path, "supervisedlogratios.R"))
> 
> # Method Settings
> nlam = 200
> intercept = TRUE
> K = 5
> rho.type = "square"
> 
> # Simulation settings
> numSims = 3
> n = 100
> p = 200
> rho = 0 # 0.2, 0.5
> # indices.theta = sample(1:(p - 1), 5, replace = FALSE) # choose bt 1 and p - 1
> # indices.theta = c(159, 179, 14, 195, 170) # the randomly chosen, above
> # indices.theta = 1 # saturated -- all 200 taxa
> indices.theta = p - 1 # sparse -- only 2 taxa
> # indices.theta = c(197, 198, 199) # log ratios with 2 taxa each
> values.theta = NULL
> sigma_eps = 0.5
> seed = 1
> 
> muW = c(
+   rep(log(p), 5), 
+   rep(0, p - 5)
+ )
> SigmaW = matrix(0, p, p)
> for(i in 1:p){
+   for(j in 1:p){
+     SigmaW[i, j] = rho^abs(i - j)
+   }
+ }
> 
> SigmaWtree = hclust(as.dist(1 - SigmaW), method = "complete")
> U = getU(btree = SigmaWtree) # U
> 
> ################################################################################
> # Simulations #
> ################################################################################
> 
> # set.seed(1)
> evals = foreach(
+   b = 1:numSims, 
+   .combine = cbind
+ ) %dorng% {
+   library(limSolve)
+   library(mvtnorm)
+   library(Matrix)
+   library(glmnet)
+   library(compositions)
+   library(stats)
+   library(balance) # for sbp.fromHclust()
+   
+   source("RCode/func_libs.R")
+   source(paste0(functions_path, "supervisedlogratios.R"))
+   
+   nlam = 200
+   
+   # simulate training data #
+   # generate W
+   W = rmvnorm(n = n, mean = muW, sigma = SigmaW) # n x p
+   # let X = exp(w_ij) / (sum_k=1:p w_ik) ~ Logistic Normal (the covariates)
+   V = exp(W)
+   rowsumsV = apply(V, 1, sum)
+   X = V / rowsumsV
+   epsilon = rnorm(n, 0, sigma_eps)
+   Xb = computeBalances(X, U = U) # ilr(X) # ilr(X)
+   # get theta
+   theta = rep(0, p - 1)
+   if(is.null(values.theta)){
+     theta[indices.theta] = 1
+   } else{
+     if(length(indices.theta) != length(values.theta)){
+       stop("indices.theta does not have same length as values.theta")
+     }
+     theta[indices.theta] = values.theta
+   }
+   theta = as.matrix(theta)
+   # get beta
+   beta = getBeta(theta, U = U)
+   # generate Y
+   Y = Xb %*% theta + epsilon
+   
+   # simulate test data #
+   # simulate independent test set of size n
+   # generate W
+   W.test = rmvnorm(n = n, mean = muW, sigma = SigmaW) # n x p
+   # let X = exp(w_ij) / (sum_k=1:p w_ik) ~ Logistic Normal (the covariates)
+   V.test = exp(W.test)
+   rowsumsV.test = apply(V.test, 1, sum)
+   X.test = V.test / rowsumsV.test
+   epsilon.test = rnorm(n, 0, sigma_eps)
+   Xb.test = computeBalances(X.test, U = U) # ilr(X)
+   # generate Y
+   Y.test = Xb.test %*% theta + epsilon.test
+   
+   # apply oracle, using CV to select lambda
+   oracle = cvILR(y = Y, X = X, btree = SigmaWtree, U = U, nlam = nlam, nfolds = K,
+               intercept = intercept)
+   
+   # choose lambda
+   lam.min.idx = which.min(oracle$cvm)
+   lam.min = oracle$lambda[lam.min.idx]
+   a0 = oracle$int[lam.min.idx]
+   thetahat = oracle$bet[, lam.min.idx]
+   Uhat = U # since it's the oracle case ########################################
+   betahat = getBeta(thetahat, U = U)
+ 
+   # evaluate model #
+   # 1. prediction error #
+   # 1a. on training set #
+   # get prediction error on training set
+   Yhat.train = a0 + computeBalances(X, U = U) %*% thetahat
+   PE.train = crossprod(Y - Yhat.train) / n
+   # 1b. on test set #
+   # get prediction error on test set
+   Yhat.test = a0 + computeBalances(X.test, U = U) %*% thetahat
+   PE.test = crossprod(Y.test - Yhat.test) / n
+   # 2. estimation accuracy #
+   # 2a. estimation of beta #
+   EA1 = sum(abs(betahat - beta))
+   EA2 = sqrt(crossprod(betahat - beta))
+   EAInfty = max(abs(betahat - beta))
+   # 3. selection accuracy #
+   # 3a. selection of beta #
+   non0.beta = (beta != 0)
+   non0s = sum(non0.beta)
+   non0.betahat = (betahat != 0)
+   # FP
+   FP = sum((non0.beta != non0.betahat) & non0.betahat)
+   # FN
+   FN = sum((non0.beta != non0.betahat) & non0.beta)
+   # TPR
+   TPR = sum((non0.beta == non0.betahat) & non0.betahat) / sum(non0.beta)
+   # return
+   c(PE.train, PE.test, EA1, EA2, EAInfty, FP, FN, TPR, sum(non0.beta))
+ }
gdata: read.xls support for 'XLS' (Excel 97-2004) files ENABLED.

gdata: Unable to load perl libaries needed by read.xls()
gdata: to support 'XLSX' (Excel 2007+) files.

gdata: Run the function 'installXLSXsupport()'
gdata: to automatically download and install the perl
gdata: libaries needed to support Excel XLS and XLSX formats.

Attaching package: ‘gdata’

The following object is masked from ‘package:stats’:

    nobs

The following object is masked from ‘package:utils’:

    object.size

The following object is masked from ‘package:base’:

    startsWith

gdata: read.xls support for 'XLS' (Excel 97-2004) files ENABLED.

gdata: Unable to load perl libaries needed by read.xls()
gdata: to support 'XLSX' (Excel 2007+) files.

gdata: Run the function 'installXLSXsupport()'
gdata: to automatically download and install the perl
gdata: libaries needed to support Excel XLS and XLSX formats.

Attaching package: ‘gdata’

The following object is masked from ‘package:stats’:

    nobs

The following object is masked from ‘package:utils’:

    object.size

The following object is masked from ‘package:base’:

    startsWith

gdata: read.xls support for 'XLS' (Excel 97-2004) files ENABLED.

gdata: Unable to load perl libaries needed by read.xls()
gdata: to support 'XLSX' (Excel 2007+) files.

gdata: Run the function 'installXLSXsupport()'
gdata: to automatically download and install the perl
gdata: libaries needed to support Excel XLS and XLSX formats.

Attaching package: ‘gdata’

The following object is masked from ‘package:stats’:

    nobs

The following object is masked from ‘package:utils’:

    object.size

The following object is masked from ‘package:base’:

    startsWith

> rownames(evals) = c("PEtr", "PEte", "EA1", "EA2", "EAInfty", "FP", "FN", "TPR", "betaSparsity")
> 
> eval.means = apply(evals, 1, mean)
> eval.sds = apply(evals, 1, sd)
> eval.ses = eval.sds / sqrt(numSims)
> evals.df = data.frame("mean" = eval.means, "sd" = eval.sds, "se" = eval.ses)
> evals.df
                     mean           sd           se
PEtr           0.23392716   0.05188056  0.029953257
PEte           0.27165230   0.01643136  0.009486651
EA1            0.34884376   0.13819769  0.079788475
EA2            0.12693761   0.00794969  0.004589756
EAInfty        0.07615887   0.01744136  0.010069774
FP           120.00000000 104.73299385 60.467622190
FN             0.00000000   0.00000000  0.000000000
TPR            1.00000000   0.00000000  0.000000000
betaSparsity   2.00000000   0.00000000  0.000000000
> 
> saveRDS(
+   evals, 
+   file = paste0(output_dir,
+                 "/oracle_cv_sims", 
+                 "_SigmaW", 
+                 "_theta_", paste(indices.theta, collapse = "_"),
+                 "_dim", n, "x", p, 
+                 "_rho", rho, 
+                 "_int", intercept,
+                 "_seed", rng.seed,
+                 ".rds"))
> saveRDS(
+   evals.df, 
+   file = paste0(output_dir,
+                 "/oracle_cv_summaries", 
+                 "_SigmaW", 
+                 "_theta_", paste(indices.theta, collapse = "_"),
+                 "_dim", n, "x", p, 
+                 "_rho", rho, 
+                 "_int", intercept,
+                 "_seed", rng.seed,
+                 ".rds"))
> 
> proc.time()
   user  system elapsed 
  7.023   1.388  43.425 
